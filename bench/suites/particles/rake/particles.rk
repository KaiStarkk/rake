(* Particle simulation in Rake *)
(* Demonstrates SoA layout, rails, and vectorized operations *)

(* Stack particle data - each field is a rack of values *)
stack Particle = {
  x: float rack;
  y: float rack;
  z: float rack;
  vx: float rack;
  vy: float rack;
  vz: float rack;
  mass: float rack
}

(* Vector math operations - ML-style params *)
crunch add a b = a + b

crunch sub a b = a - b

crunch mul a b = a * b

crunch div a b = a / b

(* Safe square root with rails - handles negative inputs *)
rake safe_sqrt x =
  | valid := x >= 0.0 -> sqrt(x)
  | otherwise -> 0.0

(* Magnitude of 3D vector *)
crunch magnitude x y z =
  let x2 = x * x in
  let y2 = y * y in
  let z2 = z * z in
  safe_sqrt(x2 + y2 + z2)

(* Normalize 3D vector - x component *)
crunch normalize_x x y z =
  let mag = magnitude(x, y, z) in
  x / mag

(* Normalize 3D vector - y component *)
crunch normalize_y x y z =
  let mag = magnitude(x, y, z) in
  y / mag

(* Normalize 3D vector - z component *)
crunch normalize_z x y z =
  let mag = magnitude(x, y, z) in
  z / mag

(* Clamp value between min and max *)
rake clamp x <min> <max> =
  | low := x < <min> -> <min>
  | high := x > <max> -> <max>
  | otherwise -> x

(* Apply gravity - modifies velocity based on mass *)
crunch apply_gravity vy mass =
  let <gravity> = 9.81 in
  vy - <gravity> * mass * 0.016

(* Update position from velocity *)
crunch update_position pos vel =
  let <dt> = 0.016 in
  pos + vel * <dt>

(* Bounce off boundary - return new position *)
rake bounce_pos pos vel <limit> =
  | below := pos < 0.0 -> 0.0 - pos
  | above := pos > <limit> -> <limit> - (pos - <limit>)
  | otherwise -> pos

(* Bounce off boundary - return new velocity *)
rake bounce_vel pos vel <limit> =
  | below := pos < 0.0 -> 0.0 - vel * 0.8
  | above := pos > <limit> -> 0.0 - vel * 0.8
  | otherwise -> vel

(* Distance between two points *)
crunch distance x1 y1 z1 x2 y2 z2 =
  let dx = x2 - x1 in
  let dy = y2 - y1 in
  let dz = z2 - z1 in
  magnitude(dx, dy, dz)

(* Collision detection - returns 1 if colliding, 0 otherwise *)
rake check_collision dist radius <threshold> =
  | collide := dist < radius + <threshold> -> 1.0
  | otherwise -> 0.0

(* Fade out dying particles *)
rake fade alpha <decay> =
  | alive := alpha > 0.01 -> alpha * <decay>
  | otherwise -> 0.0

(* Dot product of two 3D vectors *)
crunch dot x1 y1 z1 x2 y2 z2 =
  x1 * x2 + y1 * y2 + z1 * z2

(* Reflect vector off surface normal *)
crunch reflect_x vx vy vz nx ny nz =
  let d = dot(vx, vy, vz, nx, ny, nz) in
  vx - 2.0 * d * nx

crunch reflect_y vx vy vz nx ny nz =
  let d = dot(vx, vy, vz, nx, ny, nz) in
  vy - 2.0 * d * ny

crunch reflect_z vx vy vz nx ny nz =
  let d = dot(vx, vy, vz, nx, ny, nz) in
  vz - 2.0 * d * nz


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~ Ray-Sphere Intersection in Rake 0.2.0
~~
~~ Demonstrates the tine/through/sweep execution model:
~~ - Tines (#name) declare mask patterns (the teeth of the rake)
~~ - Through blocks execute under masks (data flows through)
~~ - Sweep collects results (gathering filtered lanes)
~~
~~ 8 rays processed in parallel. Each may hit or miss the sphere.
~~ Auto-vectorizers fail here because lanes diverge. Rake handles it naturally.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~ Type Definitions: Structure-of-Arrays layout for SIMD efficiency

stack Ray {
  ox : float rack,
  oy : float rack,
  oz : float rack,
  dx : float rack,
  dy : float rack,
  dz : float rack
}

stack Hit {
  t  : float rack,
  px : float rack,
  py : float rack,
  pz : float rack,
  nx : float rack,
  ny : float rack,
  nz : float rack
}

single Sphere {
  cx : float,
  cy : float,
  cz : float,
  radius : float
}

~~ Helper Functions: Pure vector computations

crunch dot ax ay az bx by bz -> d:
  d <- ax * bx + ay * by + az * bz

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~ Intersection: The key divergent computation
~~
~~ Some rays hit the sphere, others miss.
~~ Rake handles this naturally:
~~ 1. Tines define the mask patterns
~~ 2. Through blocks compute under masks
~~ 3. Sweep collects the appropriate result for each lane
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

rake intersect ray <sphere> <epsilon> -> hit:
  ~~ Quadratic formula setup (all lanes compute)
  let ocx = ray.ox - <sphere.cx>
  let ocy = ray.oy - <sphere.cy>
  let ocz = ray.oz - <sphere.cz>

  let a = dot(ray.dx, ray.dy, ray.dz, ray.dx, ray.dy, ray.dz)
  let b = <2.0> * dot(ocx, ocy, ocz, ray.dx, ray.dy, ray.dz)
  let c = dot(ocx, ocy, ocz, ocx, ocy, ocz) - <sphere.radius> * <sphere.radius>

  let disc = b * b - <4.0> * a * c

  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ~~ TINE DECLARATIONS (define mask patterns)
  ~~
  ~~   lanes:     0   1   2   3   4   5   6   7
  ~~   ──────────────────────────────────────────
  ~~   #miss:     █   ░   █   █   ░   ░   █   ░     (disc < 0)
  ~~   #maybe:    ░   █   ░   ░   █   █   ░   █     (disc >= 0)
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  | #miss  := (disc < <0.0>)
  | #maybe := (!#miss)

  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ~~ THROUGH BLOCKS (data flows through tine filters)
  ~~
  ~~        ↓↓↓↓↓↓↓↓  (8 rays enter)
  ~~   ════════════════════════════
  ~~        ↓ ↓↓↓ ↓   (#miss blocks some)
  ~~   ════════════════════════════
  ~~          ↓↓↓ ↓   (compute t for survivors)
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ~~ Compute t for rays that might hit (#maybe = disc >= 0)
  through #maybe:
    let sqrt_disc = sqrt(disc)
    let t_val = (- b - sqrt_disc) / (<2.0> * a)
    t_val
  -> t_value

  ~~ Miss result: t = -1
  through #miss:
    let miss_t = < -1.0>
    Hit {
      t := miss_t,
      px := <0.0>, py := <0.0>, pz := <0.0>,
      nx := <0.0>, ny := <0.0>, nz := <0.0>
    }
  -> miss_result

  ~~ For actual hits, compute full intersection info
  through #maybe:
    let px = ray.ox + t_value * ray.dx
    let py = ray.oy + t_value * ray.dy
    let pz = ray.oz + t_value * ray.dz

    let inv_r = <1.0> / <sphere.radius>
    let nx = (px - <sphere.cx>) * inv_r
    let ny = (py - <sphere.cy>) * inv_r
    let nz = (pz - <sphere.cz>) * inv_r

    Hit {
      t := t_value,
      px := px, py := py, pz := pz,
      nx := nx, ny := ny, nz := nz
    }
  -> maybe_result

  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ~~ SWEEP (collect results based on which tines each lane passed)
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  sweep:
    | #miss  -> miss_result
    | #maybe -> maybe_result
  -> hit

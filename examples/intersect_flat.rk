~~ Flattened Ray-Sphere Intersection for direct MLIR testing
~~ All parameters are explicit float racks or scalars

crunch dot ax ay az bx by bz -> d:
  d <- ax * bx + ay * by + az * bz

rake intersect_flat
  ray_ox ray_oy ray_oz ray_dx ray_dy ray_dz
  <sphere_cx> <sphere_cy> <sphere_cz> <sphere_r>
  -> t_result:

  ~~ Quadratic formula setup
  let ocx = ray_ox - <sphere_cx>
  let ocy = ray_oy - <sphere_cy>
  let ocz = ray_oz - <sphere_cz>

  let a = dot(ray_dx, ray_dy, ray_dz, ray_dx, ray_dy, ray_dz)
  let b = <2.0> * dot(ocx, ocy, ocz, ray_dx, ray_dy, ray_dz)
  let c = dot(ocx, ocy, ocz, ocx, ocy, ocz) - <sphere_r> * <sphere_r>

  let disc = b * b - <4.0> * a * c

  ~~ Tine declarations
  | #miss  := (disc < <0.0>)
  | #maybe := (!#miss)

  ~~ Compute t for rays that might hit
  through #maybe:
    let sqrt_disc = sqrt(disc)
    let t = (- b - sqrt_disc) / (<2.0> * a)
    t
  -> t_value

  ~~ Miss result: t = -1
  through #miss:
    let neg_one = < -1.0>
    neg_one
  -> miss_result

  sweep:
    | #miss  -> miss_result
    | #maybe -> t_value
  -> t_result
